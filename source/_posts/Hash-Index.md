---
title: Hash Index
tags:
  - db
description: 本篇简单介绍Hash索引
date: 2016-05-07 17:11:37
---

#### 散列表

#### Hash索引

Hash索引是基于Hash表（散列表）实现的，只有精确匹配索引的所有列的查询才是有效的。因为实现基于散列表，存储引擎会对每个索引值计算一个散列值，索引结构中最终存储其散列值以及指向数据行的指针。

我们知道Hash查找速度是很快的，但是也有其缺点：

1. 不能利用覆盖索引，由于Hash索引只存储散列值和索引，而不存储字段的真实值，也就没有办法只通过检索索引结构就得到返回值，必须进行行读取操作才能拿到目标值。
2. Hash索引也不支持部分索引列匹配查找，因为Hash索引是用全部索引列作为关键字来计算散列值的。单单只使用部分索引列的查询是无法通过散列函数计算出正确的目的值。
3. Hash索引只支持等值比较，不支持任何范围查询
4. Hash索引无法用于排序，因为Hash索引数据并不是有序的
5. 在有很多Hash碰撞的情况下，一些索引维护操作的代价将会很高。
6. 在有很多Hash碰撞的情况下，查询效率也会有所降低

以MySQL的Memory引擎为例，Memory引擎默认索引类型就是Hash索引，同时也是支持B-Tree索引的，它在处理碰撞的时候，使用的是拉链法，它会把散列值相同的索引以链表的形式挂在Hash表条目后。

** 我们回忆下链表的结构 ** 

链表是一种线性表，但不是按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针。相对于顺序表而言，链表对于插入删除操作有着非常高的效率，其时间复杂度为O(1)的复杂度，缺点是查找操作需要O(n)的时间。顺序表的插入更新删除时间复杂度是O(logn)，但是每次插入更新删除操作都会涉及到大量元素的移动。

接着来看Memory引擎的Hash索引，它使用拉链法处理碰撞。当碰撞很多时，其后挂链表就会变得很长，而链表对于查找的时间复杂为O(n)，也就是说随着碰撞的增多，其查询效率会显著降低。

也有算法实现采用把后挂链表改为挂载一颗平衡二叉查找树来提高其查询效率，有兴趣的可以去看看具体思想和实现。