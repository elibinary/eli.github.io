<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="db," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="在接触到 redis 的时候，看到最多的关于 redis 特性的介绍就是：单线程处理模式，高吞吐，内存 k-v 等等。随着使用和了解的加深，一定会产生很多疑问：  redis 所有操作都是在一个线程上执行的吗？ 为啥 redis 单线程也能有这么高吞吐量？ redis 为啥不用多线程呢？ redis 的 I/O 多路复用具体体现在哪一块？  单线程模型Redis 最初设计时选择了使用单线程模型，这">
<meta name="keywords" content="db">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 线程模型">
<meta property="og:url" content="http://elibinary.com/2020/07/08/62-Redis-Thread-Model/index.html">
<meta property="og:site_name" content="Sora">
<meta property="og:description" content="在接触到 redis 的时候，看到最多的关于 redis 特性的介绍就是：单线程处理模式，高吞吐，内存 k-v 等等。随着使用和了解的加深，一定会产生很多疑问：  redis 所有操作都是在一个线程上执行的吗？ 为啥 redis 单线程也能有这么高吞吐量？ redis 为啥不用多线程呢？ redis 的 I/O 多路复用具体体现在哪一块？  单线程模型Redis 最初设计时选择了使用单线程模型，这">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-09-12T05:35:59.336Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis 线程模型">
<meta name="twitter:description" content="在接触到 redis 的时候，看到最多的关于 redis 特性的介绍就是：单线程处理模式，高吞吐，内存 k-v 等等。随着使用和了解的加深，一定会产生很多疑问：  redis 所有操作都是在一个线程上执行的吗？ 为啥 redis 单线程也能有这么高吞吐量？ redis 为啥不用多线程呢？ redis 的 I/O 多路复用具体体现在哪一块？  单线程模型Redis 最初设计时选择了使用单线程模型，这">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> Redis 线程模型 | Sora </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en,zh-Hans,zh-hk,default">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <!-- <span class="logo-line-before"><i></i></span> -->
      <span class="site-title">Sora</span>
      <!-- <span class="logo-line-after"><i></i></span> -->
    </a>
  </div>
  <p class="site-subtitle">Trick</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Redis 线程模型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-07-08T15:35:09+08:00" content="2020-07-08">
              2020-07-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/07/08/62-Redis-Thread-Model/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/08/62-Redis-Thread-Model/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在接触到 redis 的时候，看到最多的关于 redis 特性的介绍就是：单线程处理模式，高吞吐，内存 k-v 等等。随着使用和了解的加深，一定会产生很多疑问：</p>
<ul>
<li>redis 所有操作都是在一个线程上执行的吗？</li>
<li>为啥 redis 单线程也能有这么高吞吐量？</li>
<li>redis 为啥不用多线程呢？</li>
<li>redis 的 I/O 多路复用具体体现在哪一块？</li>
</ul>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>Redis 最初设计时选择了使用单线程模型，这个选择其实有多方面考量，当然其主要依据点也出发自最关键的：单线程模型到底对运行性能的影响有多大。关于这一点，<a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores" target="_blank" rel="noopener">Redis FAQ 有一个问答</a></p>
<blockquote>
<p><strong>Redis is single threaded. How can I exploit multiple CPU / cores?</strong><br>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.<br>…</p>
</blockquote>
<p>我们知道，多线程技术能够帮助我们充分利用 CPU 资源来并发的执行任务，减少 CPU 空闲时间。但正如上面回答所说，CPU 并不是 Redis 的性能瓶颈，Redis 并不是一个 <a href="https://zh.wikipedia.org/wiki/CPU%E5%AF%86%E9%9B%86%E5%9E%8B" target="_blank" rel="noopener">CPU 密集型应用</a>。(<a href="https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean" target="_blank" rel="noopener">What do the terms “CPU bound” and “I/O bound” mean?</a>)</p>
<p>所有的 Redis 操作都会在内存中完成，并不会涉及到任何的 I/O 操作（这里是指 c-s 正常读写操作，不包括 AOF 备份，RDB 保存等）。数据的读写只发生在内存中，其处理速度是非常快的（if RAM is rated at 3200 MHz, it performs 3.2 billion cycles per second）。正如上面 FQA 所说，在一个普通的 Linux 服务起上 Redis 也能在 1s 处理 1,000,000 个 requests。</p>
<p>Redis 服务的瓶颈还是在于网络 I/O：等待&amp;读取客户端请求数据，写入&amp;传输结果数据。Redis 使用 I/O 多路复用机制来并发处理来自客户端的多个连接，同时等待多个连接发送的请求。</p>
<h3 id="同步非阻塞-I-O"><a href="#同步非阻塞-I-O" class="headerlink" title="同步非阻塞 I/O"></a>同步非阻塞 I/O</h3><p>传统的 <code>阻塞 I/O</code> 工作方式是：当对一个文件描述符(fd)进行 read/write 操作时，如果当前 fd 不可读或不可写（比如数据未就绪），那么当前执行线程就会阻塞等待，直到 fd 可操作。该方式简单直观，同时也是我们经常用到的方式。</p>
<p>Redis 服务器是一个事件驱动程序，它基于 Reactor 模式实现了自己的网络事件处理器（file event handler）：</p>
<ul>
<li>事件处理器使用 I/O 多路复用程序来同时监听多个 socket</li>
<li>socket ready 事件有 accept、read、write、close 等</li>
<li>handler 监听到对应 ready 事件产生后，就会调用 socket 之前关联好的处理函数</li>
</ul>
<p>虽然<code>事件处理器</code>是以单线程方式运行的，但通过 I/O 多路复用技术，这即实现了高性能的网络通信模型，又能很好的与 Redis 服务中的其他同样是单线程方式运行的模块进行对接。</p>
<p>Redis 的 I/O 多路复用程序的所有功能都是通过封装常见 I/O 多路复用函数库(select, epoll, evport, kqueue 等)来实现的。在编译的时候会自动选择系统中支持的性能最高的函数库来使用。</p>
<h3 id="Redis-是否所有操作都是在一个线程上执行"><a href="#Redis-是否所有操作都是在一个线程上执行" class="headerlink" title="Redis 是否所有操作都是在一个线程上执行"></a>Redis 是否所有操作都是在一个线程上执行</h3><p>Redis 使用单线程来处理客户端命令的一系列操作：</p>
<ul>
<li>请求获取(socket 读)</li>
<li>数据解析</li>
<li>命令执行</li>
<li>结果返回(socket 写)</li>
</ul>
<p>其请求命令的执行是完全串行执行的（在主线程上）<br>但其实 Redis 也有其他线程在工作，比如 4.x 版本之后引入的异步处理线程，主要用来异步处理一些耗时的删除操作：</p>
<ul>
<li>UNLINK</li>
<li>FLUSHALL ASYNC</li>
<li>FLUSHDB ASUNC</li>
</ul>
<p>其主要目的是：避免在删除一些超大键值时，长时间的 block 主线程导致服务吞吐降低。想 UNLINK 命令在主线程中其实只是把 key 从元数据中删除，真正的删除释放操作会在后台异步执行。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Redis 使用单线程模型来处理 request 主要是因为 CPU 不是 Redis 的瓶颈，而使用多线程模型在可能获得有限的性能提升的同时也将带来高出很多的开发成本和维护成本。</p>
<p>但从另一方面看，单线程模型也限制了单个 Redis 服务对 CPU 多核的利用，对此官方 FQA 是这么建议的：</p>
<blockquote>
<p>However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking of some way to shard earlier.</p>
</blockquote>
<p>官方建议可以开启多个 Redis 实例，并通过分区来分担压力，关于分区可以参阅：<a href="https://redis.io/topics/partitioning" target="_blank" rel="noopener">Partitioning: how to split data among multiple Redis instances.</a><br>但同时数据分区也会引入分布式存储常见的问题：</p>
<ul>
<li>热点数据问题</li>
<li>数据偏斜</li>
<li>扩/缩节点和重新分配问题</li>
</ul>
<p>上面问题是分布式存储复制&amp;分区所要面对的常见问题，在这里不展开了</p>
<h2 id="Redis-6-0-引入的多线程模型"><a href="#Redis-6-0-引入的多线程模型" class="headerlink" title="Redis 6.0 引入的多线程模型"></a>Redis 6.0 引入的多线程模型</h2><p>在上一章中有提到 Redis 的主要瓶颈在于网络 I/O（request socket 读/写），之前版本使用单线程来处理这些逻辑，6.0 版本引入的多线程模型主要针对此进行改进。</p>
<p>Redis 主线程的时间主要消耗的两方面：</p>
<ul>
<li>逻辑计算</li>
<li>同步 I/O 读写，数据拷贝</li>
</ul>
<p>新的多线程模型，使用一组单独的线程专门处理 socket 读/写调用以及数据解析工作，命令执行依然由主线程来串行执行。</p>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/db/" rel="tag">#db</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/22/61-DDIA-Transaction/" rel="next" title="DDIA-分布式存储-事务">
                <i class="fa fa-chevron-left"></i> DDIA-分布式存储-事务
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2020/07/08/62-Redis-Thread-Model/"
           data-title="Redis 线程模型" data-url="http://elibinary.com/2020/07/08/62-Redis-Thread-Model/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="Eli Binary" />
          <p class="site-author-name" itemprop="name">Eli Binary</p>
          <p class="site-description motion-element" itemprop="description">First I have a dream.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">86</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#单线程模型"><span class="nav-number">1.</span> <span class="nav-text">单线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步非阻塞-I-O"><span class="nav-number">1.1.</span> <span class="nav-text">同步非阻塞 I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-是否所有操作都是在一个线程上执行"><span class="nav-number">1.2.</span> <span class="nav-text">Redis 是否所有操作都是在一个线程上执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">1.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-6-0-引入的多线程模型"><span class="nav-number">2.</span> <span class="nav-text">Redis 6.0 引入的多线程模型</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eli Binary</span>
</div>

<div>
  Better late than never.
</div>
<!-- <div class="powered-by"> -->
  <!-- Powered by <a class="theme-link" href="http://hexo.io">Hexo</a> -->
<!-- </div> -->

<!-- <div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div> -->



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"sooraa"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
