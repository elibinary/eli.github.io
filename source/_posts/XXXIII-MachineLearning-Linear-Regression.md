---
title: 简单机器学习模型 - Linear Regression
date: 2017-07-30 14:34:31
tags:
  - MachineLearning
description: 回归算法是监督式机器学习算法非常重要且常用的一个分类，经常被用来建立各种预测模型。本篇对其进行大致介绍，并用健康习惯记录 - 打卡记录训练数据尝试建立线性回归模型的例子来帮助理解
---

回归算法是监督式机器学习算法非常重要且常用的一个分类，经常被用来建立各种预测模型。

## Regression Algorithm

简单来说，假设我们有一个数据集，把其中每个数据项都是看作是给定空间的一个点，那么就可以得到一个点的集合，那么回归就是用一个函数去对这个点的集合进行拟合，使得点集与这个函数的偏差最小。

### Linear Regression
线性回归的预测模型，也可以说是拟合函数是一个一次方程或者叫线性方程。

比如我们有一个数据集
\begin{array}{cc}
\mathrm{x} & \mathrm{y} \\
\hline \\
\mathrm{x_1} & \mathrm{y_1} \\
\mathrm{x_2} & \mathrm{y_2} \\
\mathrm{x_3} & \mathrm{y_3} \\
\mathrm{x_4} & \mathrm{y_4} \\
\mathrm{x_5} & \mathrm{y_5} \\
\end{array}

为了拟合这些点，建立一个简单线性回归模型：
$$ y=ax + b $$
接下来要做的就是估计该模型的参数，来使得我们的模型对数据达到最佳拟合状态。

线性回归把关注点放在给定 x 值的 y 的条件概率分布，而不是 x 和 y 的联合概率分布。

在计算一个最佳拟合的不同标准之中，最小二乘法是最常用的算法。

> 最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。 -- from wiki

最小二乘法通过最小化每个数据点到线的垂直偏差平方和来计算最佳拟合线。
$$ \sum_{i=1}^m (y^i - f(x^i))^2 $$

推广至多元线性回归，那就是影响目标值 y 的元素有多个：
$$ y=ax + bz + cm + dn $$
有数据：
\begin{array}{cc}
\mathrm{y} & \mathrm{x} & \mathrm{m} & \mathrm{n} \\
\hline \\
\mathrm{x_1} & \mathrm{y_1} & \mathrm{m_1} & \mathrm{n_1} \\
\mathrm{x_2} & \mathrm{y_2} & \mathrm{m_2} & \mathrm{n_2}\\
\mathrm{x_3} & \mathrm{y_3} & \mathrm{m_3} & \mathrm{n_3}\\
\mathrm{x_4} & \mathrm{y_4} & \mathrm{m_4} & \mathrm{n_4}\\
\mathrm{x_5} & \mathrm{y_5} & \mathrm{m_5} & \mathrm{5_1}\\
\end{array}

线性回归是机器学习中一个最简单的监督学习(Supervised Learning)模型

---

---

*下面我对健康习惯的用户做了抽样，样本大小是 2000，并尝试对其健康习惯记录情况与首页打卡情况建立线性回归模型*

```
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn import datasets, linear_model

def get_data(file_name):
  data = pd.read_csv(file_name)
  x_p = []
  y_p = []
  for habit_records ,checkin_records in zip(data['habits'],data['checkins']):
    x_p.append([float(habit_records)])
    y_p.append(float(checkin_records))
  return x_p,y_p

def linear_model_main(x_p,y_p):
  regr = linear_model.LinearRegression()
  regr.fit(x_p, y_p)
  predictions = {}
  predictions['intercept'] = regr.intercept_
  predictions['coefficient'] = regr.coef_
  print(predictions)
  return predictions
  
x, y = get_data('linear_date.csv')
linear_model_main(x, y)
```

我把样本数据写在一个 csv 文件中，（感叹下，python 处理起 csv 和 ruby 一样方便呀省了不少事）

数据大概是这样：
```
[[[2.0], 6.0], [[43.0], 3.0], [[1.0], 2.0], [[165.0], 2.0], [[31.0], 3.0], [[10.0], 2.0], [[16.0], 2.0], [[12.0], 3.0], [[136.0], 5.0], [[5.0], 2.0], [[3.0], 2.0], [[1.0], 182.0], [[1.0], 6.0], [[7.0], 45.0], [[3.0], 2.0], [[5.0], 10.0], [[4.0], 2.0], [[5.0], 5.0], [[3.0], 31.0], [[10.0], 10.0], [[6.0], 72.0], [[185.0], 4.0], [[11.0], 18.0], [[62.0], 2.0], [[6.0], 2.0], [[26.0], 372.0], [[114.0], 2.0], [[6.0], 2.0], [[9.0], 17.0], [[7.0], 41.0], [[325.0], 2.0], [[4.0], 3.0], [[6.0], 2.0], [[29.0], 11.0], [[1.0], 4.0], [[1.0], 3.0], [[9.0], 41.0], [[1.0], 2.0], [[3.0], 6.0], [[5.0], 2.0], [[4.0], 2.0], [[5.0], 53.0], [[4.0], 13.0], [[1.0], 2.0], [[2.0], 20.0], [[11.0], 14.0], [[19.0], 2.0], [[3.0], 2.0], [[47.0], 3.0], [[1.0], 2.0], [[15.0], 2.0], [[7.0], 9.0], [[2.0], 2.0], [[1.0], 3.0], [[4.0], 2.0], [[5.0], 53.0], [[119.0], 2.0], [[15.0], 2.0], [[9.0], 5.0], [[3.0], 3.0], [[97.0], 2.0], [[83.0], 9.0], [[5.0], 8.0], [[5.0], 2.0], [[152.0], 2.0], [[3.0], 9.0], [[276.0], 2.0], [[65.0], 2.0], [[30.0], 2.0], [[195.0], 187.0], [[11.0], 7.0], [[51.0], 7.0], [[15.0], 4.0], [[16.0], 2.0], [[1.0], 15.0], [[10.0], 5.0], [[9.0], 52.0], [[6.0], 4.0], [[5.0], 2.0], [[4.0], 51.0], [[7.0], 41.0], [[5.0], 2.0], [[17.0], 431.0], [[1.0], 2.0], [[5.0], 3.0], [[25.0], 3.0], [[5.0], 2.0], [[1.0], 2.0], [[1.0], 2.0], [[7.0], 11.0], [[20.0], 7.0], [[6.0], 3.0], [[4.0], 82.0], [[3.0], 4.0], [[9.0], 37.0], [[1.0], 2.0], [[2.0], 2.0], [[61.0], 2.0], [[3.0], 3.0], [[6.0], 2.0], [[2.0], 3.0], [[53.0], 4.0], [[25.0], 2.0], [[38.0], 159.0] ... ]
```

最后得到的截距值为：21.606768655113363，斜率是：[ 0.02046425]
画出拟合后的函数图像来就像这样：
```
def show_linear_line(x_p,y_p):
  regr = linear_model.LinearRegression()
  regr.fit(x_p, y_p)
  plt.scatter(x_p,y_p, color='blue')
  plt.plot(x_p,regr.predict(x_p),color='red',linewidth=4)
  plt.xticks(())
  plt.yticks(())
  plt.show()
```
![linear habits checins][1]

可以看出，线性回归对于异常的值或者说是脱离正常预测的值是非常敏感的。显而易见这个模型非常不平衡，而最佳模型就是取得预测偏差和模型方差之间的平衡。**预测偏差过高就是拟合不够，方差过高就是拟合过度**。

解决高方差有几种思路，比如可以尝试获取更多的训练样本，或者减少所使用特征的集合，也就是减少影响集。
而解决高偏差，可以尝试使用其他特征，或者增加多项组合特征。

我对于 健康习惯记录数 - 打卡数 的线性拟合尝试所得到的结果表明，这两个动作看起来并没有明显的线性关系。或许我应该增加新的特征维度来约束其回归。

---

---


  [1]: http://7xsger.com1.z0.glb.clouddn.com/image/jpg/linear_habit_checkin_1.png
