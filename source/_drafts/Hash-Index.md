---
title: Hash-Index
tags:
  - db
description: 本篇主要简单介绍下Hash索引。
---

散列表就是根据关键字不需比较便可直接取得所查记录在内存存储位置的数据结构。

一般来说对于一个关键字k，使用一个对应关系f(k)将其映射到表中一个位置，因此下次再拿关键字k来查询时，可以使用对应关系f(x)直接到指定位置去获取其存储值而无需进行比较。这个对应关系f(x)就是散列函数。

散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来重新创建一个叫做散列值的指纹。
对于散列函数有几个性质：

1. 对于一个散列函数，如果散列值是不相同的，那么这散列值的原始输入也是不相同的
2. 散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为哈希碰撞。
3. 散列函数是不可逆的，也就是说对于给定的散列值，没有实用的方法可以计算出一个原始输入

> 典型的散列函数都有非常大的定义域，比如SHA-2最高接受(2^64-1)/8长度的字节字符串。

先介绍一下填充因子的概念：

其定义为：a = 填入表中的元素个数 / 散列表的长度

a是散列表装满程度的标志因子。由于表长是定值，a与“填入表中的元素个数”成正比，所以，a越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之，a越小，标明填入表中的元素越少，产生冲突的可能性就越小。(摘自wiki)

对不同的关键字可能得到同一散列地址现象称为冲突，也就是碰撞。把每个关键字映射到唯一的索引上的理想散列函数几乎是不存在的，我们需要对碰撞做处理，这里介绍两个常用的方法：

1. 开放定址法，其中心思想就是如果根据散列函数f(x)得到的散列值发生碰撞，那么就在此值的基础上根据一定算法再计算得到一个新的位置，如果新的位置也碰撞就再根据上面的算法再计算知道找到可用的散列值为止。根据探测的策略不同有如下分类
  - 线性探测法，就相当于逐个的探测表中地址，知道找到可用的地址，如果探测一遍都找不到可用地址则此次插入失败，这种做法实现简单但相对的容易产生数据的堆聚现象
  - 平方探测法，将线性探测的步长改为冲突次数的平方数进行探测
  - 随机探测法，将线性探测的步长改为随机数，这样能使不同的关键字具有不同的探测次序，从而可以减少堆聚现象

2. 拉链法，其中心思想是将所有散列值相等的关键字值存到一个单链表中
