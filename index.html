<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Sora, Trick" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="First I have a dream.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sora">
<meta property="og:url" content="http://elibinary.com/index.html">
<meta property="og:site_name" content="Sora">
<meta property="og:description" content="First I have a dream.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sora">
<meta name="twitter:description" content="First I have a dream.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> Sora </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en,zh-Hans,zh-hk,default">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <!-- <span class="logo-line-before"><i></i></span> -->
      <span class="site-title">Sora</span>
      <!-- <span class="logo-line-after"><i></i></span> -->
    </a>
  </div>
  <p class="site-subtitle">Trick</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/07/08/62-Redis-Thread-Model/" itemprop="url">
                  Redis 线程模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-07-08T15:35:09+08:00" content="2020-07-08">
              2020-07-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/07/08/62-Redis-Thread-Model/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/08/62-Redis-Thread-Model/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          redis 所有操作都是在一个线程上执行的吗?
          <div class="post-more-link text-center">
            <a class="btn" href="/2020/07/08/62-Redis-Thread-Model/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/06/22/61-DDIA-Transaction/" itemprop="url">
                  DDIA-分布式存储-事务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-06-22T19:23:09+08:00" content="2020-06-22">
              2020-06-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/06/22/61-DDIA-Transaction/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/22/61-DDIA-Transaction/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          事务的基本定义：事务中的所有读写操作被视为单个操作来执行，整个事务要么成功，要么失败回滚，不存在执行一半的情况。如果失败，应用程序可以安全的重试
          <div class="post-more-link text-center">
            <a class="btn" href="/2020/06/22/61-DDIA-Transaction/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/06/16/60-Go-Sourse-Sync/" itemprop="url">
                  源码阅读-Go Sync
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-06-16T18:30:58+08:00" content="2020-06-16">
              2020-06-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/06/16/60-Go-Sourse-Sync/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/16/60-Go-Sourse-Sync/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          sync pkg 是我们在并发编程中经常使用到的一个包，它提供了锁，信号同步，单次加载等非常有用的功能
          <div class="post-more-link text-center">
            <a class="btn" href="/2020/06/16/60-Go-Sourse-Sync/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/05/14/59-Go-Sourse-Context/" itemprop="url">
                  源码阅读-Go Context
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-05-14T21:29:45+08:00" content="2020-05-14">
              2020-05-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/05/14/59-Go-Sourse-Context/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/14/59-Go-Sourse-Context/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>go/src/context/context.go</p>
</blockquote>
<p>context pkg 整体代码量比较少<br>首先来看下 context pkg 的组成</p>
<p>其中定义了三个 interface:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Context interface &#123;...&#125;</span><br><span class="line"></span><br><span class="line">type canceler interface &#123;...&#125;</span><br><span class="line">type stringer interface &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>和三个继承了 Context 的 struct:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 实现了 canceler interface</span><br><span class="line">type cancelCtx struct &#123;</span><br><span class="line">type timerCtx struct &#123;</span><br><span class="line"></span><br><span class="line">type valueCtx struct &#123;</span><br></pre></td></tr></table></figure></p>
<p>上面结构构成了 context pkg 主要的功能主体</p>
<h2 id="Context-interface"><a href="#Context-interface" class="headerlink" title="Context interface"></a>Context interface</h2><blockquote>
<p>A Context carries a deadline, a cancellation signal, and other values across API boundaries.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Context interface &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key interface&#123;&#125;) interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interface 定义的四个方法都是操作幂等的（successive calls to Method return the same response.）</p>
<p><code>Deadline()</code> 方法可以用来实现 timeout 相关逻辑<br><code>Done()</code> 方法会返回一个只读的 channel，用来同步 Context 结束状态<br><code>Err()</code> 方法用来返回 Context 是为什么 close 的，正常情况下返回 nil<br><code>Value(key interface{})</code> 方法可以用来实现不同协程上下文间变量传递，最常见的是用来传 trace id</p>
<h3 id="Empty-Context"><a href="#Empty-Context" class="headerlink" title="Empty Context"></a>Empty Context</h3><p>在实际使用中，我们可能会经常用到 Context pkg 的两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    background = new(emptyCtx)</span><br><span class="line">    todo       = new(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Background() Context &#123;</span><br><span class="line">    return background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TODO() Context &#123;</span><br><span class="line">    return todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，这两个方法在行为上是一模一样的，都是返回一个 empty struct<br>不过在含义上，这两个方法拥有不同的意义及推荐用法：</p>
<p><code>Background()</code> 一般用来创建 top-level Context (Context 的 root node) 或测试<br><code>TODO()</code> 则一般用作占位，由于 Context 官方推荐用法是放在函数的第一参数位且不推荐传递 nil，当重构代码或其他情况没有可用的 ctx 的时候，可以先用来占位</p>
<p>回到上文，emptyCtx 实际上就是个实现了 Context 的实体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type emptyCtx int</span><br><span class="line">func (*emptyCtx) Deadline() (deadline time.Time, ok bool) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">func (*emptyCtx) Done() &lt;-chan struct&#123;&#125; &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">func (*emptyCtx) Err() error &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">func (*emptyCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有方法实现均什么也不做直接返回空值<br>简单来说它就是一个空的 Context，永远不会 canceled，没有 values，没有 deadline<br>可以看到 emptyCtx 并未被导出，一般我们在包外都是通过 <code>Background()</code> 和 <code>TODO()</code> 来使用初始化好的 emptyCtx</p>
<p>接下来看下经常用到的几个包方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;...&#125;</span><br><span class="line">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) &#123;...&#125;</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) &#123;...&#125;</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>WithCancel</code> 用来创建一个 cancelable 的 Context<br><code>WithDeadline</code> 用来创建一个有 deadline 的 Context<br><code>WithTimeout</code> 是对 WithDeadline 进一步封装的糖果方法<br><code>WithValue</code> 用来创建存储了 k-v 的 Context</p>
<h2 id="Cancel-Context"><a href="#Cancel-Context" class="headerlink" title="Cancel Context"></a>Cancel Context</h2><p>cancelable 的 ctx 依托于 <code>cancelCtx</code> struct 实现，先看下这个 struct：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type canceler interface &#123;</span><br><span class="line">    cancel(removeFromParent bool, err error)</span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type cancelCtx struct &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            // protects following fields</span><br><span class="line">    done     chan struct&#123;&#125;         // created lazily, closed by first cancel call</span><br><span class="line">    children map[canceler]struct&#123;&#125; // set to nil by the first cancel call</span><br><span class="line">    err      error                 // set to non-nil by the first cancel call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cancelCtx 直接将 interface Context 作为一个匿名属性，所以它也是一个 Context</p>
<p>同时 cancelCtx 实现了 canceler interface<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (c *cancelCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;...&#125;</span><br><span class="line">func (c *cancelCtx) Done() &lt;-chan struct&#123;&#125; &#123;...&#125;</span><br><span class="line">func (c *cancelCtx) Err() error &#123;...&#125;</span><br><span class="line">func (c *cancelCtx) cancel(removeFromParent bool, err error) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中最重要的是 cancel 方法（下面源码中 [Comment By Eli] 部分为追加注释）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// cancel closes c.done, cancels each of c&apos;s children, and, if</span><br><span class="line">// removeFromParent is true, removes c from its parent&apos;s children.</span><br><span class="line">func (c *cancelCtx) cancel(removeFromParent bool, err error) &#123;</span><br><span class="line">    // [Comment By Eli] cancel context 时，必须传入 err 指明原因</span><br><span class="line">    if err == nil &#123;</span><br><span class="line">        panic(&quot;context: internal error: missing cancel error&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    if c.err != nil &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        return // already canceled</span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    // [Comment By Eli] 此处处理是由于 c.done 是懒加载的，只有第一次调用 Done() 方法时才会初始化 channel</span><br><span class="line">    // [Comment By Eli] closedchan 是包级别变量，定义了一个可充用的已经 closed 的 channel</span><br><span class="line">    if c.done == nil &#123;</span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        close(c.done)</span><br><span class="line">    &#125;</span><br><span class="line">    // [Comment By Eli] 把所有 child context 一并 cancel 掉（递归式的，包括 child 的 childs）</span><br><span class="line">    for child := range c.children &#123;</span><br><span class="line">        // NOTE: acquiring the child&apos;s lock while holding parent&apos;s lock.</span><br><span class="line">        child.cancel(false, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = nil</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    // [Comment By Eli] 为 true 此处会把当前 context 从 parent 的 children map 中删除</span><br><span class="line">    if removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cancel</code> 方法总结：</p>
<ol>
<li>设置当前 ctx.err 来指明 cancel 的原因</li>
<li>close 掉当前 ctx.done 这个 channel，以广播给监听该 channel 的人发送关闭通知</li>
<li>递归式的把 child ctx 全部 cancel 掉</li>
<li>把自己从父节点的 children map 中移除</li>
</ol>
<p>先来看下一个 cancelable Context 是如何创建的，代码很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    // [Comment By Eli] 必须有一个父节点</span><br><span class="line">    if parent == nil &#123;</span><br><span class="line">        panic(&quot;cannot create context from nil parent&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    // [Comment By Eli] 向上找一个 cancelCtx 把自己挂上去</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newCancelCtx(parent Context) cancelCtx &#123;</span><br><span class="line">    return cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建方法很简单，主要做了两件事：</p>
<ol>
<li>初始化一个 cancelCtx struct，<code>cancelCtx{Context: parent}</code></li>
<li>向上找一个可用的 cancelCtx 把自己挂上去</li>
</ol>
<p>挂载这个动作涉及到 context 的运作方式，在看 <code>propagateCancel()</code> 方法之前，我们先把其他几个 ctx 看完</p>
<h2 id="Deadline-Context"><a href="#Deadline-Context" class="headerlink" title="Deadline Context"></a>Deadline Context</h2><p>with deadline 的 ctx 依托于 <code>timerCtx</code> struct 实现，先看下这个 struct：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type timerCtx struct &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer // Under cancelCtx.mu.</span><br><span class="line"></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>timerCtx</code> 内嵌了 cancelCtx 以继承它的基础方法如：<code>Done(), Err(), Value()</code><br><code>timerCtx</code> 还包装了 cancelCtx 的 <code>cancel()</code> 方法来实现 timer<br>它提供的主要功能就是一个可定时关闭的 cancelCtx</p>
<p>我们来看下它的 <code>cancel()</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (c *timerCtx) cancel(removeFromParent bool, err error) &#123;</span><br><span class="line">    // [Comment By Eli] 调用继承来的 cancel 方法来关闭自己</span><br><span class="line">    c.cancelCtx.cancel(false, err)</span><br><span class="line">    if removeFromParent &#123;</span><br><span class="line">        // Remove this timerCtx from its parent cancelCtx&apos;s children.</span><br><span class="line">        removeChild(c.cancelCtx.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    // [Comment By Eli] 加入计时器未关闭，就关掉它节省资源同时避免再次触发 cancel</span><br><span class="line">    if c.timer != nil &#123;</span><br><span class="line">        c.timer.Stop()</span><br><span class="line">        c.timer = nil</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法实现很简单，来看下创建逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) &#123;</span><br><span class="line">    if parent == nil &#123;</span><br><span class="line">        panic(&quot;cannot create context from nil parent&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // [Comment By Eli] 假如父节点的 Deadline 比当前要创建的早，就直接创建一个 cancelCtx（因为父节点 Deadline 到期时就会 cancel 掉子节点）</span><br><span class="line">    if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">        // The current deadline is already sooner than the new one.</span><br><span class="line">        return WithCancel(parent)</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;timerCtx&#123;</span><br><span class="line">        cancelCtx: newCancelCtx(parent),</span><br><span class="line">        deadline:  d,</span><br><span class="line">    &#125;</span><br><span class="line">    propagateCancel(parent, c)</span><br><span class="line">    dur := time.Until(d)</span><br><span class="line">    // [Comment By Eli] 已经 Deadline 已经到期了，直接 cancel 掉</span><br><span class="line">    if dur &lt;= 0 &#123;</span><br><span class="line">        c.cancel(true, DeadlineExceeded) // deadline has already passed</span><br><span class="line">        return c, func() &#123; c.cancel(false, Canceled) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    defer c.mu.Unlock()</span><br><span class="line">    // [Comment By Eli] 起一个 timer，当定时到期时执行 cancel</span><br><span class="line">    if c.err == nil &#123;</span><br><span class="line">        c.timer = time.AfterFunc(dur, func() &#123;</span><br><span class="line">            c.cancel(true, DeadlineExceeded)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要逻辑有两个地方需要注意：</p>
<ol>
<li>加入要创建的 ctx deadline 比当前的 parent deadline 要晚，由于 parent cancel 的时候会把 chailds 都 cancel 掉，那么这个 deadline 就没有意义了，因为 parent 一定比它早结束。这时候就直接创建一个 cancelCtx 就行了 <code>return WithCancel(parent)</code></li>
<li>另一个就是定时自动关闭的核心，使用 Timer 的 <a href="https://golang.org/pkg/time/#AfterFunc" target="_blank" rel="noopener">func AfterFunc</a> 方法来实现定时逻辑</li>
</ol>
<p>而另一个 <code>WithTimeout</code> 则是对 <code>WithDeadline</code> 的封装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) &#123;</span><br><span class="line">    return WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Value-Context"><a href="#Value-Context" class="headerlink" title="Value Context"></a>Value Context</h2><p>value ctx 主要实现为 context 提供 K-V 数据存储传递功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type valueCtx struct &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的主要方法 <code>Value</code> 实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (c *valueCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">    if c.key == key &#123;</span><br><span class="line">        return c.val</span><br><span class="line">    &#125;</span><br><span class="line">    return c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现非常简单，就是递归的向上查找对应 key 的 val，直到找到或返回 nil</p>
<p>创建方法逻辑也很简洁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context &#123;</span><br><span class="line">    if parent == nil &#123;</span><br><span class="line">        panic(&quot;cannot create context from nil parent&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if key == nil &#123;</span><br><span class="line">        panic(&quot;nil key&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        panic(&quot;key is not comparable&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的就是 key 的类型一定要是可比较的，因为后面 get 的时候需要用到 <code>==</code></p>
<h2 id="How-It-Works"><a href="#How-It-Works" class="headerlink" title="How It Works"></a>How It Works</h2><p>从上面源码中创建 ctx 的方式可以看出来，ctx 在整体运行中是链式结构的，更加准确的说其实是树形结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                       -- cancelCtx2</span><br><span class="line">      -- cancelCtx1 --|</span><br><span class="line">     |                 -- ctx4</span><br><span class="line">ctx--|</span><br><span class="line">      -- deadlineCtx1 -- cancelCtx3 -- deadlineCtx2</span><br></pre></td></tr></table></figure>
<p>了解了 ctx 的运行时结构，我们再来看之前遗留的几个方法：<br>先看下 <code>propagateCancel</code>，这个方法在创建几种 cancelCtx 时都会调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// propagateCancel arranges for child to be canceled when parent is.</span><br><span class="line">func propagateCancel(parent Context, child canceler) &#123;</span><br><span class="line">    // [Comment By Eli] 加入父节点并不是 cancelCtx，就直接返回了</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    if done == nil &#123;</span><br><span class="line">        return // parent is never canceled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // [Comment By Eli] 否则就监听父节点的 cancel 状态</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-done:</span><br><span class="line">        // parent is already canceled</span><br><span class="line">        child.cancel(false, parent.Err())</span><br><span class="line">        return</span><br><span class="line">    default:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // [Comment By Eli] 找出潜在的 cancelCtx，把自己加入到其 children map</span><br><span class="line">    if p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        if p.err != nil &#123;</span><br><span class="line">            // parent has already been canceled</span><br><span class="line">            child.cancel(false, p.err)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if p.children == nil &#123;</span><br><span class="line">                p.children = make(map[canceler]struct&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = struct&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // [Comment By Eli] 这里我还不是特别理解，上面已经监听了 parent.Done()，为什么这里还要再单独起一个 goroutine 再去监听</span><br><span class="line">        atomic.AddInt32(&amp;goroutines, +1)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case &lt;-parent.Done():</span><br><span class="line">                child.cancel(false, parent.Err())</span><br><span class="line">            case &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>propagateCancel()</code> 方法的作用主要是：</p>
<ol>
<li>监听父节点的 close 状态，保证自身与父节点状态保持一致</li>
<li>如果父节点是 <code>cancelCtx</code> 把自己加入到父节点的 children map</li>
</ol>
<p>最后来看下 parentCancelCtx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func parentCancelCtx(parent Context) (*cancelCtx, bool) &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    if done == closedchan || done == nil &#123;</span><br><span class="line">        return nil, false</span><br><span class="line">    &#125;</span><br><span class="line">    // [Comment By Eli] 这里通过 cancelCtx.Value 方法来获取潜在的 cancelCtx</span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        return nil, false</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    ok = p.done == done</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">    if !ok &#123;</span><br><span class="line">        return nil, false</span><br><span class="line">    &#125;</span><br><span class="line">    return p, true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// [Comment By Eli] cancelCtx.Value，此处把该方法摘出来帮助理解</span><br><span class="line">func (c *cancelCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">    if key == &amp;cancelCtxKey &#123;</span><br><span class="line">        return c</span><br><span class="line">    &#125;</span><br><span class="line">    return c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="小结与思考"><a href="#小结与思考" class="headerlink" title="小结与思考"></a>小结与思考</h2><h3 id="使用-context-应该遵循的规则"><a href="#使用-context-应该遵循的规则" class="headerlink" title="使用 context 应该遵循的规则"></a>使用 context 应该遵循的规则</h3><p>官方 <a href="https://golang.org/pkg/context/" target="_blank" rel="noopener">pkg doc</a> 也给出了使用规范：</p>
<ol>
<li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx:</li>
<li>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use.</li>
<li>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li>
<li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li>
</ol>
<h3 id="关于传递共享数据"><a href="#关于传递共享数据" class="headerlink" title="关于传递共享数据"></a>关于传递共享数据</h3><p>先说结论：还是要谨慎使用 <code>valueCtx</code></p>
<p><code>valueCtx</code> 提供了传递共享数据的方式，它的工作方式上文中也有提及，简单来说就是每次调用 <code>WithValue</code> 都会创建一个节点，其中存储了一对 K-V<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx--valueCtx1--valueCtx2--valueCtx3--valueCtx4</span><br></pre></td></tr></table></figure></p>
<p>而其查找方式是递归的向上查找对应 key 的 val，当匹配到理它最近的节点，就会返回</p>
<p>如果我们在代码里滥用 <code>valueCtx</code> 进行数据共享，我们的数据状态是非常混乱的，甚至还可能存在不同时机插入同样的 key 导致在链条不同位置取出的 val 不一致的情况，极大增加后续的可维护性</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/04/12/58-DDIA-Partition/" itemprop="url">
                  DDIA-分布式存储-分区
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-04-12T13:28:22+08:00" content="2020-04-12">
              2020-04-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/04/12/58-DDIA-Partition/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/04/12/58-DDIA-Partition/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          什么是分区, 分区的目的是什么
          <div class="post-more-link text-center">
            <a class="btn" href="/2020/04/12/58-DDIA-Partition/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/02/15/57-DDIA-Replication/" itemprop="url">
                  DDIA-分布式存储-复制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2020-02-15T16:26:50+08:00" content="2020-02-15">
              2020-02-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/02/15/57-DDIA-Replication/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/02/15/57-DDIA-Replication/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          replication 和 partitioning 是两种不同的机制，但它们经常一起使用（比如 kafka 的存储）
          <div class="post-more-link text-center">
            <a class="btn" href="/2020/02/15/57-DDIA-Replication/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/11/16/56-Go-Concurrency-Model/" itemprop="url">
                  Golang 并发模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-11-16T14:12:25+08:00" content="2019-11-16">
              2019-11-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/11/16/56-Go-Concurrency-Model/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/11/16/56-Go-Concurrency-Model/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          在介绍 golang 的并发调度模型之前，先来看下几个基础知识
          <div class="post-more-link text-center">
            <a class="btn" href="/2019/11/16/56-Go-Concurrency-Model/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/12/55-DDIA-Base/" itemprop="url">
                  DDIA-分布式存储-基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-12T20:21:37+08:00" content="2019-07-12">
              2019-07-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/07/12/55-DDIA-Base/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/07/12/55-DDIA-Base/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          分布式存储-基础
          <div class="post-more-link text-center">
            <a class="btn" href="/2019/07/12/55-DDIA-Base/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/22/53-Columnar-Apache-Arrow/" itemprop="url">
                  列式存储 & Apache Arrow
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-05-22T16:43:16+08:00" content="2019-05-22">
              2019-05-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/05/22/53-Columnar-Apache-Arrow/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/22/53-Columnar-Apache-Arrow/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          参会时听到 PingCAP 的 topic 讲到 TiDB 使用 [Apache Arrow][1] 结构格式来存储数据，非常感兴趣，会后看了一些简介和文档
          <div class="post-more-link text-center">
            <a class="btn" href="/2019/05/22/53-Columnar-Apache-Arrow/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/11/52-Rack-Request-Pramas-QA/" itemprop="url">
                  Rack::Request 获取 params 的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-05-11T18:15:00+08:00" content="2019-05-11">
              2019-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2019/05/11/52-Rack-Request-Pramas-QA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/11/52-Rack-Request-Pramas-QA/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          Rack::Request 获取 params 的问题
          <div class="post-more-link text-center">
            <a class="btn" href="/2019/05/11/52-Rack-Request-Pramas-QA/">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="Eli Binary" />
          <p class="site-author-name" itemprop="name">Eli Binary</p>
          <p class="site-description motion-element" itemprop="description">First I have a dream.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">86</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eli Binary</span>
</div>

<div>
  Better late than never.
</div>
<!-- <div class="powered-by"> -->
  <!-- Powered by <a class="theme-link" href="http://hexo.io">Hexo</a> -->
<!-- </div> -->

<!-- <div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div> -->



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"sooraa"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
