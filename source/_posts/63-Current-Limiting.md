---
title: 限流思路与实现
date: 2020-10-04 20:13:33
tags:
  - Architecture
description: 为什么需要限流？一般实现思路有哪些？
---

为什么需要限流？
一般常见的限流场景有：

1. 保护性资源需要限制单位时间的使用量（例如短信验证码）
2. 因各种原因导致的流量陡增，压垮服务

## 滑动窗口
主要思路是统计单位时间内请求的数量：

1. 设置窗口大小（如 1s）
2. 设定最小时间粒度（如 100ms，则一个窗口中包含 10 个计数单位）
3. 没经过一个时间单位，就丢弃掉最老的单位计数（模拟滑动）
4. 判断时：计算当前窗口内所有计数单位的总计数

总体思路是通过对窗口内时间区间进行再次划分，以模拟窗口滑动的效果。故其统计精度取决于最小计数粒度。同时粒度越小，效率越差。

数据结构：
```go
type Window struct {
    mu sync.Mutex

    // 当前游标，模拟环形队列
    ptr int
    // 最后一次访问时间
    lastTimeMsec int64
    // 计数窗口
    window []int
    // 当前计数
    counter int
    // 精度
    msec int
}
```
思路：

* 使用环形队列存储计数单元，counter 中每个元素存储单位计数
* 环形队列：每次向前移动 ptr，超过队列长度后置 0
* 步长计算：(当前时间 - lastTimeMsec)/msec

单机情况基于内存可以很容易实现上述算法，如果需要实现分布式限流就需要借助第三方存储组件如 redis 等来辅助实现。
在 redis 中可以借助 Redis::List 结构来实现循环队列，主要依靠 `LINDEX` 和 `LSET` 命令来存取计数单元。
需要注意的是，由于整个过程需要多次 redis 操作，需要考虑原子性和多次网络 I/O 的损耗，可以使用 Lua 脚本运行的方式把计算过程都放在 Redis 侧进行。

## 令牌桶
主要思路是请求者拿到令牌才能继续访问，令牌数量按固定速率添加。
数据结构：
```go
type Bucket struct {
    // 令牌数量
    token int
    // 最后一次访问时间
    lastTimeMsec int64
    // 最大令牌数量
    maxToken int
    // 令牌生成速率(msec)
    tokenRate int
}
```
思路：

* 每次进入时判断应放入的令牌数量
* 新令牌数计算：(当前时间 - lastTimeMsec) * tokenRate
* 判断令牌数量，如等于 0 就标记为被限流
* 更新令牌数量，返回限流标记

